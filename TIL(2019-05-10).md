### TIL(2019-05-10) Convention, Test 등등 (수업)

---

- 정성적인 부분에서는 정답이 없기 때문에 정답을 찾기 보다는 지속적인 개선으로 최선을 찾아가야 한다.



- 코드 컨벤션은 이력서의 증명사진과 같다. 코드의 첫인상은 코드 컨벤션이 결정한다.



- Code Convention

  - 상수는 static final로 선언한다. 
    - 상수는 어차피 값이 바뀌지 않는데 굳이 사용할 때마다 새로 만들 필요가 없기 때문에 static으로 선언한다.
    - 메서드의 인자도 final로 받는 게 좋다. 
  - method의 순서는? public method가 먼저 나오고 그 다음에 private method가 나온다. public이 사용하는 private method를 public method의 뒤에 연속적으로 작성한다. 
  - 공백
    - 메소드의 시작부분에 공백을 없애야 한다.
    - 공백은 메소드 안의 기능을 다른 메소드로 분리할 때 기준점에 대한 힌트를 주기도 한다. 공백을 기준으로 메소드를 분리할 수 있다는 것.
  - 스페이스
    - 스페이스도 컨벤션이다.
  - 이름 짓기
    - 이름 짓기는 중요하고 어려운 것임을 느끼고 있는 게 중요하다. 이름 짓는 것이 어렵지 않으면 잘못하고 잇는 것.
    - 자료구조나 특정 타입에 종속된 이름을 피한다. carList나 carNameString과 같이 프로그래밍의 관점에서 이름을 짓지 마라. 그냥 carNames가 낫다. 변수의 의미를 드러낼 수 있게 하자. 
    - carNames라는 String 타입의 데이터를 List로 변환해서 사용해야 하는 경우, List를 이름에 포함시켜야 하는지를 고민하기보다는 그 메서드에 해당 변수가 있는 게 맞는지 다시 생각해보자. 

  

- Setter와 Getter는 최대한 사용하지 말자. 클래스는 데이터를 담기고 옮기는 것만 수행하는 게 아니라 로직이 있어야 한다. 

  - Test 코드를 위해서라도 setter와 getter를 쓰는 건 좋지 않다. 
  - setter로 인해 버그 발생 가능성이 높아진다.

  

- 인스턴스 변수는 정말 진짜 특별한 경우가 아니라면 private으로 구현



- 인스턴스의 상태를 변경할 경우 그 행동은 인스턴스가 가지고 있어야 한다. Car 클래스가 move를 가지고 있어야지 외부에서 '1 이동!'을 시키는 것은 좋지 않다. `메시지를 보내자!`



- 한 객체의 상태 변화가 다른 객체에 영향을 줄 경우 A 객체에 먼저 메시지를 보내고 A객체에서 의존 관계를 가지고 있는 B객체에 다시 메시지를 보내는 방식으로 메시지를 보내야 한다.



- Random값 테스트.

  - 테스트하기 어려운 경우에는 테스트가 가능한 것과 테스트하기 어려운 부분을 나누어봐야 한다. 

  - ```java
    private void move() {
        if (randomNum() >= 4) {
            position++;
        }
    }
    
    private void
    ```



- 객체와 객체를 비교 테스트할 때 get 메서드가 아니라 객체와 객체를 직접 비교하자. 
  - 상태를 가지는 객체는 hashcode와 equals는 가지고 있어야 한다. 이건 테스트 코드를 위해 배보다 배꼽이 큰 코드를 만들어내는 것이 아니라, 필수적으로 가지고 있어야할 기능을 놓친 것은 테스트를 통해 파악하는 것이다.
  - equals나 hashcode는 제일 아래에 위치시키는 것이 일반적인 컨벤션이다.



- 프로덕션 코드와 테스트 코드는 한 번에 커밋하는 게 좋다. 프로덕션 코드와 테스트 코드는 같이 다니는 게 좋다.
  - 테스트 코드의 커밋 단위는 하나 하나 할 수도 있지만 하나의 기능을 테스트하는 여러 개의 테스트 코드를 뭉쳐서 커밋해도 된다. 



- 테스트는 경계값을 가지고 하는 것이 좋다. 모든 값을 다 테스트할 수는 없기 때문에.
  - 입력받은 값이 4 이상일 경우 행동하라는 메서드는 경계값이 3과 4를 테스트하는 게 좋다.



- 테스트를 하다보면 메소드의 위치가 바뀌기도 한다. 



- 생성자에서 다른 생성자를 호출할 때는 this를 사용한다. 인자가 적은 생성자에서 인자가 많은 생성자를 호출하는 방식을 주로 사용한다. 기본값을 지정해서 호출하면 된다. 



- String은 불변객체이다. String + String은 새로운 String을 만드는 것이다. 그런데 왜 String을 불변객체로 만들었을까?



- 생성자를 만드는 것과 setPosition을 만드는 게 무엇이 다른가? 생성자를 통해 만들면 상태를 바꿀 수 없다. 그러나 setPosition은 언제든지 상태를 바꿔지기 할 수 있는 차이가 있다. setter를 쓰면 instance들고 다니다가 중간에 조작을 해서 버그가 발생할 가능성, 해킹의 위험 등이 있다. setter로 인해 가변객체가 된다. 



- 인스턴스 변수의 수를 최소화하자. 인스턴스 변수를 추가해야 할 경우, 이미 있는 변수로 구해낼 수 있는지 확인하자. `인스턴스를 2개까지 허용하는 제약조건을 걸고 연습해보자.`



- 재사용의 빈도가 높은 데이터의 경우 인스턴스를 만드는 것이 좋을 수 있는데 그런 상황에서는 개로운 객체를 만들어서 사용하는 것이 좋을 수 있다. Winner 클래스에 Car리스트와 Winner들의 이름 리스트를 둘 다 변수로 가질 수 있는데 Winner들의 이름 리스트를 따로 클래스에 빼서 사용할 수 있다. 메소드 분리, 클래스 분리를 두려워 말자. 



- 코드의 성능 만큼이나 유지보수의 효율, 가독성의 효율이 중요하다. 더 중요할 수도 있다. 



- 비즈니스 로직과 UI 로직을 분리하자. 

---

#### 공부할 것

`Junit, AssertJ의 기본적인 함수를 공부하자`

`StringUtils 공부`

`Math.random 등 random만드는 함수들 비교 정리`

`java 재귀`

`클래스 변수, 메서드, 인스턴스 변수, 메서드 구분 공부`

`equals, hashcode, toString() 등 공부`

`String은 불변객체이다. String + String은 새로운 String을 만드는 것이다. 그런데 왜 String을 불변객체로 만들었을까?`